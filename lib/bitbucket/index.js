'use strict';

var util = require('util');
var request = require('request');

/**
 * config:
 *  log: logger to use
 *  version: '2.0' - the Bitbucket API version to use. Defaults to '2.0'
 *  auth: {
 *     consumerKey - consumer key for the API (get from BitBucket integration dashboard)
 *     consumerSecret - consumer secret for the API (get from BitBucket integration dashboard)
 *     token - token that was generated by BitBucket for the user
 *     refreshToken - refresh token that was generated by BitBucket for the user
 *  }
 */
function Bitbucket(config) {
  this.config = config || {};
  this.log = config.log.child({consumerKey: config.auth.consumerKey});

  this.authenticate(config.auth);

  // bind all methods to this so context of this.repos.method is still this.
  var subs = ['repos', 'statuses'];
  var sub;
  var method;

  for (let i in subs) {
    sub = subs[i];

    // make sure we don't bind the prototype function to this!
    let newSub = {};

    for (let m in this[sub]) {
      method = this[sub][m];
      if (typeof method.bind == 'function') {
        newSub[m] = method.bind(this);
      }
    }

    this[sub] = newSub;
  }
}

Bitbucket.prototype.utils = {
  extend: function(dest, src) {
    dest = dest || {};
    src = src || {};

    var ret = {};
    var x;

    for (x in dest) {
      ret[x] = dest[x];
    }

    for (x in src) {
      ret[x] = src[x];
    }

    return ret;
  },

  defaults: function(dest, src) {
    dest = dest || {};
    src = src || {};

    var ret = {};
    var x;

    for (x in dest) {
      ret[x] = dest[x];
    }

    for (x in src) {
      if (typeof dest[x] == 'undefined') {
        ret[x] = src[x];
      }
    }

    return ret;
  },
};

/**
 * Synchronous call that sets up the HTTP client with the proper auth
 */

Bitbucket.prototype.authenticate = function(auth) {
  if (!auth) {
    throw new Error('Bitbucket authentication config missing');
  }

  this.auth = this.utils.defaults(auth, this.auth);

  this.oauth = {
    headers: this.makeAuthHeaders(this.auth.token),
  };
};

/**
 * opts: all standard request call options with the addition of the following (that
 * don't get passed to request):
 *
 * method - lowercases HTTP method, with "del" instead of "DELETE" (defaults to "get")
 * path (appended to this.url)
 */
Bitbucket.prototype.http = function(opts, cb) {
  var self = this;

  // always grab a new token
  this.refreshToken.bind(this)(function(err, auth) {
    if (err) { return cb(err); }

    return self._http(opts, cb);
  });
};

Bitbucket.prototype._http = function(opts, cb) {
  opts = opts || {};
  var method = opts.method || 'get';
  var version = opts.version || '2.0';
  var url = `https://api.bitbucket.org/${version}`;

  opts = this.utils.defaults(opts, {
    uri: opts.url || (url + opts.path),
    headers: this.utils.defaults(this.oauth.headers, opts.headers),
    json: true,
  });

  delete opts.version;
  delete opts.url;
  delete opts.method;
  delete opts.path;

  function handler(err, res, body) {
    if (err) return cb(err);

    if (!(res.statusCode >= 200 && res.statusCode < 300)) {
      err = new Error(JSON.stringify(body));
      err.statusCode = res.statusCode;
      err.statusMessage = res.statusMessage;

      return cb(err);
    }

    cb(err, res, body);
  }

  return request[method](opts, handler);
};

// Bitbucket.prototype.performRequest = function(method, opts, done) {
//   var self = this;
//   var cb = function(error, response, body) {
//     if (error) {
//       if (self.isTokenError(body)) {
//         self.log.info('Invalid bitbucket auth, attempting to refresh token');
//         return self.retryRequestWithFreshToken(method, opts, done);
//       }
//       else {
//         let msg = `Request to bitbucket failed with status code ${response.status}: ${body}`;
//         self.log.error({err: error, body: body}, msg);
//         return done(new Error(msg));
//       }
//     }
//     // console.log(response);
//     done(null, body);
//   };
//   request[method](opts, cb);
// };

// Bitbucket.prototype.retryRequestWithFreshToken = function(method, opts, handler, attempts) {
//   var self = this;
//   var localAttempts = attempts || 0;
//   self.refreshToken(function(err, auth) {
//     if (err) {
//       return handler(err);
//     }

//     opts.headers = self.makeAuthHeaders(auth.access_token);

//     self.performRequest(method, opts, function(error, data) {
//       if ((self.isTokenError(data) || error) && attempts < 2) {
//         // return and call this again incrementing attempts
//         return self.retryRequestWithFreshToken(method, opts, handler, attempts++);
//       }
//       handler(error, data);
//     });
//   });
// };

Bitbucket.prototype.refreshToken = function(done) {
  var self = this;
  this.log.info('refreshing token');

  var opts = {
    uri: 'https://bitbucket.org/site/oauth2/access_token',
    form: {
      grant_type: 'refresh_token',
      refresh_token: this.auth.refreshToken,
    },
    auth: {
      user: this.auth.consumerKey,
      pass: this.auth.consumerSecret,
    },
    json: true,
  };

  request.post(opts, function(error, response, body) {
    if (error) {
      return done(error);
    }

    self.log.info({auth: body.access_token}, 'refreshed auth token from BB');

    // we have new auth credentials, so update auth with them
    self.authenticate({token: body.access_token});
    done(null, body);
  });
};

Bitbucket.prototype.isTokenError = function(body) {
  return (body &&
          body.error &&
          body.error.message === 'Access token expired. Use your refresh token to obtain a new access token.');
};

Bitbucket.prototype.makeAuthHeaders = function(token) {
  return {
    authorization: `Bearer ${token}`,
  };
};

// need:
//   repos
//     getAll
//     getContent (directory and file contents)
//       - getContent({user: project.owner, repo: project.repo, ref: sha, path: ''})
//       - getContent({user: project.owner, repo: project.repo, ref: sha, path: file.path})
//   statuses
//     create

Bitbucket.prototype.repos = {
  // getAll: function(opts, cb) {
  //   if (typeof opts == 'function') {
  //     cb = opts;
  //     opts = {};
  //   }

  //   var params = this.utils.defaults(opts, {
  //     qs: {limit: 100, permission: 'REPO_ADMIN'},
  //     path: '/rest/api/1.0/repos',
  //   });

  //   this.http(params, function(err, res, repos) {
  //     if (err) return cb(err);

  //     // repos:
  //     // "size": 1,
  //     //     "limit": 25,
  //     //     "isLastPage": true,
  //     //     "values": [
  //     //         {
  //     //             "slug": "my-repo",
  //     //      ...

  //     // drill down into actual repos array
  //     repos = repos.values;

  //     cb(err, repos);
  //   });
  // },

  /**
   * Gets content of files (path specified) or directories (no path)
   */
  getContent: function(opts, cb) {
    if (typeof opts == 'function') {
      cb = opts;
      opts = {};
    }

    if (!opts.accountName) {
      return cb(new Error('getContent accountName required'));
    }
    if (!opts.repositorySlug) {
      return cb(new Error('getContent repositorySlug required'));
    }

    opts.path = opts.path || '';
    opts.ref = opts.at || opts.ref;
    var path = `/repositories/${opts.accountName}/${opts.repositorySlug}/src/${opts.ref}/${opts.path}`;

    delete opts.path;
    delete opts.at;
    delete opts.ref;

    var params = {
      version: '1.0',
      path,
    };

    this.http(params, function(err, res, content) {
      if (err) return cb(err);

      if (content.data) {
        // getting contents of a file
        content = content.data;
      }
      else if (content.path) {
        content = content.files;
      }

      cb(err, content);
    });
  },
};

Bitbucket.prototype.statuses = {
  create: function(status, opts, cb) {
    if (typeof opts == 'function') {
      cb = opts;
      opts = {};
    }

    // validate status
    if (!status) {
      return cb(new Error('statuses.create status required'));
    }

    var requiredStatusFields = ['state', 'key', 'url'];
    var field;
    for (var i in requiredStatusFields) {
      field = requiredStatusFields[i];
      if (!status[field]) {
        return cb(new Error('statuses.create status.' + field + ' required'));
      }
    }

    // automatically uppcase state
    status.state = status.state.toUpperCase();
    var validStates = ['SUCCESSFUL', 'FAILED', 'INPROGRESS'];
    if (validStates.indexOf(status.state) < 0) {
      return cb(new Error('statuses.create status.' + field + ' required to be one of ' + ['SUCCESSFUL', 'FAILED', 'INPROGRESS'].join(', ')));
    }

    // validate opts
    if (!opts.commitId && !opts.ref) {
      return cb(new Error('statuses.create commitId or ref config required'));
    }

    var ref = opts.commitId || opts.ref;
    var path = util.format('/repositories/%s/commit/%s/statuses/build',
                           opts.slug, ref);

    delete opts.commitId;
    delete opts.ref;
    delete opts.slug;

    var params = this.utils.defaults(opts, {
      path: path,
      method: 'post',
      body: status,
      json: true,
    });

    this.http(params, function(err, res, content) {
      if (err) return cb(err);

      if (content && content.errors) {
        return cb(new Error(content.errors[0].message));
      }

      cb(err, content);
    });
  },
};


module.exports = Bitbucket;
