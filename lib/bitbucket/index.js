'use strict';

var util = require('util');
var request = require('request');

/**
 * config:
 *  log: logger to use
 *  version: '2.0' - the Bitbucket API version to use. Defaults to '2.0'
 *  auth: {
 *     consumerKey - consumer key for the API (get from BitBucket integration dashboard)
 *     consumerSecret - consumer secret for the API (get from BitBucket integration dashboard)
 *     token - token that was generated by BitBucket for the user
 *     refreshToken - refresh token that was generated by BitBucket for the user
 *  }
 */
function Bitbucket(config) {
  this.config = config || {};
  this.log = config.log;

  var version = config.version || '2.0';
  this.url = `https://api.bitbucket.org/${version}`;
  this.authenticate(config.auth);

  // bind all methods to this so context of this.repos.method is still this.
  var subs = ['repos', 'statuses'];
  var sub;
  var method;

  for (let i in subs) {
    sub = subs[i];
    for (let m in this[sub]) {
      method = this[sub][m];
      if (typeof method.bind == 'function') {
        this[sub][m] = method.bind(this);
      }
    }
  }
}

Bitbucket.prototype.utils = {
  extend: function(dest, src) {
    dest = dest || {};
    src = src || {};

    var ret = {};
    var x;

    for (x in dest) {
      ret[x] = dest[x];
    }

    for (x in src) {
      ret[x] = src[x];
    }

    return ret;
  },

  defaults: function(dest, src) {
    dest = dest || {};
    src = src || {};

    var ret = {};
    var x;
    
    for (x in dest) {
      ret[x] = dest[x];
    }

    for (x in src) {
      if (typeof dest[x] == 'undefined') {
        ret[x] = src[x];
      }
    }

    return ret;
  },
};

/**
 * Synchronous call that sets up the HTTP client with the proper auth
 */

Bitbucket.prototype.authenticate = function(auth) {
  // create both oauth and refreshoauth
  if (!auth) {
    throw new Error('Bitbucket authentication config missing');
  }

  this.refreshOAuth = {
    uri: 'https://bitbucket.org/site/oauth2/access_token',
    form: {
      grant_type: 'refresh_token',
      refresh_token: auth.refreshToken,
    },
    auth: {
      user: auth.consumerKey,
      pass: auth.consumerSecret,
    },
    json: true,
  };

  this.oauth = {
    headers: this.makeAuthHeader(auth.token),
  };
};

/**
 * opts: all standard request call options with the addition of the following (that
 * don't get passed to request):
 *
 * method - lowercases HTTP method, with "del" instead of "DELETE" (defaults to "get")
 * path (appended to this.url)
 */
Bitbucket.prototype.http = function(opts, cb) {
  opts = opts || {};
  var method = opts.method || 'get';

  opts = this.utils.defaults(opts, {
    uri: this.url + opts.path,
    headers: this.oauth.headers,
    json: true,
  });

  delete opts.method;
  delete opts.path;

  function handler(err, res, body) {
    if (err) return cb(err);

    if (!(res.statusCode >= 200 && res.statusCode < 300)) {
      err = new Error(JSON.stringify(body));
      err.statusCode = res.statusCode;
      err.statusMessage = res.statusMessage;

      return cb(err);
    }

    cb(err, res, body);
  }

  return request[method](opts, handler);
  //return this.performRequest(method, opts, handler);
};

Bitbucket.prototype.performRequest = function(method, opts, done) {
  var self = this;
  var cb = function(error, response, body) {
    if (error) {
      console.log(error);
      console.log('ERROR');
      return done(new Error(`Request to bitbucket failed with status code ${response.status}`));
    }
    if (self.isTokenError(body)) {
      return self.retryRequestWithFreshToken(method, opts, done);
    }
    console.log(response);
    done(error, body);
  };
  request[method](opts, cb);
};

Bitbucket.prototype.retryRequestWithFreshToken = function(method, opts, handler, attempts) {
  var self = this;
  var localAttempts = attempts || 0;
  self.refreshToken(function(err, auth) {
    if(err){
      return handler(err);
    }

    opts.headers = self.makeAuthHeader(auth.access_token);
    self.performRequest(method, opts, function(error, data) {
      if ((self.isTokenError(data) || error) && attempts < 2) {
        // return and call this again incrementing attempts
        return self.retryRequestWithFreshToken(method, opts, handler, attempts++);
      }
      handler(error, data);
    });
  });
};

Bitbucket.prototype.refreshToken = function(done) {
  request.post(this.refreshOAuth, function(error, response, body) {
    if (error) {
      return done(error);
    }
    done(null, body);
  });
};

Bitbucket.prototype.isTokenError = function(body) {
  return (body &&
          body.error &&
          body.error.message === 'Access token expired. Use your refresh token to obtain a new access token.');
};

Bitbucket.prototype.makeAuthHeader = function(token) {
  return {authorization: `Bearer ${token}`};
};

// need:
//   repos
//     getAll
//     getContent (directory and file contents)
//       - getContent({user: project.owner, repo: project.repo, ref: sha, path: ''})
//       - getContent({user: project.owner, repo: project.repo, ref: sha, path: file.path})
//   statuses
//     create

Bitbucket.prototype.repos = {
  getAll: function(opts, cb) {
    if (typeof opts == 'function') {
      cb = opts;
      opts = {};
    }

    var params = this.utils.defaults(opts, {
      qs: {limit: 100, permission: 'REPO_ADMIN'},
      path: '/rest/api/1.0/repos',
    });

    this.http(params, function(err, res, repos) {
      if (err) return cb(err);

      // repos:
      // "size": 1,
      //     "limit": 25,
      //     "isLastPage": true,
      //     "values": [
      //         {
      //             "slug": "my-repo",
      //      ...

      // drill down into actual repos array
      repos = repos.values;

      cb(err, repos);
    });
  },

  /**
   * Gets content of files (path specified) or directories (no path)
   */
  getContent: function(opts, cb) {
    if (typeof opts == 'function') {
      cb = opts;
      opts = {};
    }

    if (!opts.projectKey) {
      return cb(new Error('getContent projectKey required'));
    }
    if (!opts.repositorySlug) {
      return cb(new Error('getContent repositorySlug required'));
    }

    opts.path = opts.path || '';

    var path = util.format('/rest/api/1.0/projects/%s/repos/%s/browse/%s',
                           opts.projectKey, opts.repositorySlug, opts.path);

    delete opts.path;

    var qs = {
      at: opts.at || opts.ref, // support 'ref' instead of 'at' too
      type: opts.type,
      blame: opts.blame,
      noContent: opts.noContent,
    };
    delete opts.at;
    delete opts.ref;
    delete opts.type;
    delete opts.blame;
    delete opts.noContent;

    var params = this.utils.defaults(opts, {
      qs: qs, path: path,
    });

    this.http(params, function(err, res, content) {
      if (err) return cb(err);

      //content:
      // {
      //   "size": 1,
      //   "limit": 25,
      //   "isLastPage": true,
      //   "start": 0,
      //   "lines": [
      //     {
      //       "text": "print('hello world')"
      //     }
      //   ]
      // }

      // console.log("content", util.inspect(content, null, 5));

      if (content.lines) {
        // getting contents of a file
        content = content.lines.map(function(entry) {
          return entry.text;
        }).join('\n');
      }
      else if (content.path) {
        content = content.children.values;
      }

      cb(err, content);
    });
  },
};

Bitbucket.prototype.statuses = {
  create: function(status, opts, cb) {
    if (typeof opts == 'function') {
      cb = opts;
      opts = {};
    }

    // validate status
    if (!status) {
      return cb(new Error('statuses.create status required'));
    }

    var requiredStatusFields = ['state', 'key', 'url'];
    var field;
    for (var i in requiredStatusFields) {
      field = requiredStatusFields[i];
      if (!status[field]) {
        return cb(new Error('statuses.create status.' + field + ' required'));
      }
    }

    // automatically uppcase state
    status.state = status.state.toUpperCase();
    var validStates = ['SUCCESSFUL', 'FAILED', 'INPROGRESS'];
    if (validStates.indexOf(status.state) < 0) {
      return cb(new Error('statuses.create status.' + field + ' required to be one of ' + ['SUCCESSFUL', 'FAILED', 'INPROGRESS'].join(', ')));
    }

    // validate opts
    if (!opts.commitId && !opts.ref) {
      return cb(new Error('statuses.create commitId or ref config required'));
    }

    var ref = opts.commitId || opts.ref;
    var path = util.format('/repositories/%s/commit/%s/statuses/build',
                           opts.slug, ref);

    delete opts.commitId;
    delete opts.ref;
    delete opts.slug;

    var params = this.utils.defaults(opts, {
      path: path,
      method: 'post',
      body: status,
      json: true,
    });

    this.http(params, function(err, res, content) {
      if (err) return cb(err);

      if (content && content.errors) {
        return cb(new Error(content.errors[0].message));
      }

      cb(err, content);
    });
  },
};


module.exports = Bitbucket;
